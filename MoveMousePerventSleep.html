==========> ROS２インストール　<==========
aptリポジトリの追加
sudo apt update && sudo apt install curl gnupg lsb-release
sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg

リポジトリをsource listに追加
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release && echo $UBUNTU_CODENAME) main" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null

動作テスト
Terminal1:
source /opt/ros/humble/setup.bash
ros2 run demo_nodes_cpp talker
Terminal2:
source /opt/ros/humble/setup.bash
ros2 run demo_nodes_py listener

環境設定
echo "source /opt/ros/humble/setup.bash" >> ~/.bashrc
source .bashrc
============================

#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <iostream>

const unsigned int WIDTH = 800;
const unsigned int HEIGHT = 600;

// 顶点着色器代码
const char *vertexShaderSource = R"(
    #version 330 core
    layout (location = 0) in vec2 aPos;
    layout (location = 1) in vec2 aTexCoord;
    layout (location = 2) in float aShapeIndex;

    out vec2 TexCoord;
    flat out int ShapeIndex;

    void main() {
        gl_Position = vec4(aPos, 0.0, 1.0);
        TexCoord = aTexCoord;
        ShapeIndex = int(aShapeIndex);
    }
)";

// 片段着色器代码
const char *fragmentShaderSource = R"(
    #version 330 core
    out vec4 FragColor;

    in vec2 TexCoord;
    flat in int ShapeIndex;

    uniform sampler2D texture1;

    void main() {
        vec4 color;
        if (ShapeIndex == 0) { // 矩形
            color = texture(texture1, TexCoord);
        } else if (ShapeIndex == 1) { // 三角形
            color = texture(texture1, TexCoord);
        }

        FragColor = color;
    }
)";

int main() {
    // 初始化 GLFW
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    // 创建窗口对象
    GLFWwindow *window = glfwCreateWindow(WIDTH, HEIGHT, "OpenGL Example", NULL, NULL);
    if (window == NULL) {
        std::cout << "Failed to create GLFW window" << std::endl;
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);

    // 初始化 GLAD
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        std::cout << "Failed to initialize GLAD" << std::endl;
        return -1;
    }

    // 编译着色器程序
    GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
    glCompileShader(vertexShader);

    GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
    glCompileShader(fragmentShader);

    GLuint shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glLinkProgram(shaderProgram);

    // 设置顶点数据和属性指针
    float vertices[] = {
        -1.0f, -1.0f, 0.0f, 0.0f, 0.0f, // 左下角
         1.0f, -1.0f, 0.0f, 1.0f, 0.0f, // 右下角
         1.0f,  1.0f, 0.0f, 1.0f, 1.0f, // 右上角
        -1.0f,  1.0f, 0.0f, 0.0f, 1.0f  // 左上角
    };

    unsigned int indices[] = {
        0, 1, 2,
        2, 3, 0
    };

    GLuint VAO, VBO, EBO;
    glGenVertexArrays(1, &VAO);
    glGenBuffers(1, &VBO);
    glGenBuffers(1, &EBO);

    glBindVertexArray(VAO);

    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0);

    // 渲染循环
    while (!glfwWindowShouldClose(window)) {
        // 渲染指令
        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        // 激活着色器程序
        glUseProgram(shaderProgram);

        // 绑定纹理
        // glBindTexture(GL_TEXTURE_2D, texture);

        // 渲染矩形
        glBindVertexArray(VAO);
        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);

        // 交换缓冲区和检查事件
        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    // 清理资源
    glDeleteVertexArrays(1, &VAO);
    glDeleteBuffers(1, &VBO);
    glDeleteBuffers(1, &EBO);

    glfwTerminate();
    return 0;
}

    
    
    
    
    using System;
using System.Collections.Generic;
using System.IO;

class Program
{
    static void Main(string[] args)
    {
        // 指定Markdown文件的路径
        string filePath = "path/to/your/file.md";

        try
        {
            // 读取文件内容
            string[] lines = File.ReadAllLines(filePath);

            List<Entry> entries = new List<Entry>();
            Entry currentEntry = null;

            foreach (var line in lines)
            {
                // 判断是否是ID行 (#001)
                if (line.StartsWith("#"))
                {
                    if (currentEntry != null)
                    {
                        entries.Add(currentEntry); // 添加上一个条目
                    }
                    currentEntry = new Entry();
                    currentEntry.Id = line.Trim(); // 保存ID
                }
                // 判断是否是注释行
                else if (!line.Contains("|") && !string.IsNullOrWhiteSpace(line))
                {
                    currentEntry.Comment = line.Trim(); // 保存注释
                }
                // 判断是否是字段行
                else if (line.Contains("|"))
                {
                    var fields = line.Split('|', StringSplitOptions.RemoveEmptyEntries);
                    for (int i = 0; i < fields.Length; i++)
                    {
                        fields[i] = fields[i].Trim();
                    }
                    currentEntry.Fields.Add(fields);
                }
            }

            if (currentEntry != null)
            {
                entries.Add(currentEntry); // 添加最后一个条目
            }

            // 输出解析后的内容
            foreach (var entry in entries)
            {
                Console.WriteLine($"ID: {entry.Id}");
                Console.WriteLine($"Comment: {entry.Comment}");
                foreach (var fieldSet in entry.Fields)
                {
                    Console.WriteLine(string.Join(", ", fieldSet));
                }
                Console.WriteLine();
            }
        }
        catch (Exception ex)
        {
            // 处理异常情况
            Console.WriteLine($"Error reading the file: {ex.Message}");
        }
    }
}

// 定义一个Entry类来保存每个条目的数据
class Entry
{
    public string Id { get; set; }
    public string Comment { get; set; }
    public List<string[]> Fields { get; set; } = new List<string[]>();
}
代码说明：
读取文件内容：使用 File.ReadAllLines(filePath) 方法逐行读取文件内容。
定义 Entry 类：
Id 保存条目 ID（例如 #001）。
Comment 保存注释。
Fields 是一个 List<string[]>，用于保存每行字段（用数组表示每行中的各个字段）。
解析内容：
遇到以 # 开头的行，识别为 ID 行。
如果该行不是 ID 行且不包含 |，识别为注释行。
含有 | 的行被识别为字段行，用 Split 方法分割字段，并存入 Fields 列表中。
输出解析结果：将解析后的内容结构化输出。
这个示例提供了一个基本的框架来解析你所描述的格式，你可以根据实际需求对其进行扩展。
    

